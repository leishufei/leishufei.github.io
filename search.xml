<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>谷歌、有道和百度翻译的 JS 加密参数破解</title>
    <url>/Python/2020-08-08-google-translation-js-crack/</url>
    <content><![CDATA[<p>打开开发者工具（F12），进入网络 （Network）面板，然后随便输入一个词翻译一下，观察一下新增的请求，对前端有一些了解的话，很容易知道这种内容一般是通过异步请求（XHR）返回的数据。观察发现下图红框中的请求正是我们所需要的。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p1.png" alt="p1"></p>
<p>然后分析一下请求 URL 所带的一些参数，参数有很多，不过只有 sl, tl, tk, q 是我们需要关注的，其中 sl 表示原文的语言类型，tl 表示译文的语言类型，tk 表示加密参数，需要破解，q 是我们输入的文本。</p>
<p>既然知道需要破解什么参数了，那就比较好下手了。<br>切换到源代码（Source）面板，在右边的调试工具中添加 XHR/提取（XHR/fetch）断点，内容为不带参数的 URL （即：<code>https://translate.google.cn/translate_a/single</code>），如下图所示。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p3.png" alt="p3"></p>
<p>再重新输入一个词进行翻译或者刷新一下页面，js 脚本下图中的红框处暂停了，并且产生了下图右边的调用堆栈（即函数的先后调用次序，A 被 B 调用，B 被 C 调用，以此类推，顺序从下往上）。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p4.png" alt="p4"></p>
<p>继续追根朔源，跳转到 Vj 函数，发现 Vj 的参数 a 中就带有我们所需要的 tk 参数，简直 amazing！</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p5.png" alt="p5"></p>
<p>继续往下查找，发现在 fF 函数中存在 tk 参数，而在 hF 函数中不存在，因此这个 fF 就是我们接下来要分析的目标。fF 函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fF = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) </span>&#123;<br>    c = c.toString();<br>    c += eF(d);<br>    d = d.toString();<br>    <span class="hljs-keyword">var</span> g = <span class="hljs-string">&quot;POST&quot;</span>;<br>    b += <span class="hljs-string">&quot;?&quot;</span> + c;<br>    <span class="hljs-number">2E3</span> &gt; b.length + d.length &amp;&amp; (g = <span class="hljs-string">&quot;GET&quot;</span>,<br>    b += <span class="hljs-string">&quot;&amp;&quot;</span> + d,<br>    d = <span class="hljs-string">&quot;&quot;</span>);<br>    ++a.j;<br>    <span class="hljs-keyword">return</span> Vj(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>) </span>&#123;<br>        --a.j;<br>        e(h)<br>    &#125;, g, d, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, f)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 fF 函数的第一行和最后一行打上断点，删除其余的断点，然后重新调试。当在断点处暂停后，采用步进调试的方法（防止跳过重要参数信息）。如图可见，tk 的值来源于 eF 函数，其参数 d 是一个对象，其中包含有我们输入的内容。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p6.png" alt="p6"></p>
<p>跳转到 eF 函数，分析 tk 是如何生成的。eF 函数代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eF = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    a = a.Kb(<span class="hljs-string">&quot;q&quot;</span>).join(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> Au(a)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>eF 函数中的 Kb 函数其实就是将我们所输入的文本从对象中提取出来，a 就是我们所输入的文本，然后再传给 Au 函数。继续跳转到 Au 函数进行分析，Au 函数代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Au = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !== zu)<br>        <span class="hljs-keyword">var</span> b = zu;<br>    <span class="hljs-keyword">else</span> &#123;<br>        b = xu(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">84</span>));<br>        <span class="hljs-keyword">var</span> c = xu(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">75</span>));<br>        b = [b(), b()];<br>        b[<span class="hljs-number">1</span>] = c();<br>        b = (zu = <span class="hljs-built_in">window</span>[b.join(c())] || <span class="hljs-string">&quot;&quot;</span>) || <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> d = xu(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">116</span>));<br>    c = xu(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">107</span>));<br>    d = [d(), d()];<br>    d[<span class="hljs-number">1</span>] = c();<br>    c = <span class="hljs-string">&quot;&amp;&quot;</span> + d.join(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;=&quot;</span>;<br>    d = b.split(<span class="hljs-string">&quot;.&quot;</span>);<br>    b = <span class="hljs-built_in">Number</span>(d[<span class="hljs-number">0</span>]) || <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = [], f = <span class="hljs-number">0</span>, g = <span class="hljs-number">0</span>; g &lt; a.length; g++) &#123;<br>        <span class="hljs-keyword">var</span> h = a.charCodeAt(g);<br>        <span class="hljs-number">128</span> &gt; h ? e[f++] = h : (<span class="hljs-number">2048</span> &gt; h ? e[f++] = h &gt;&gt; <span class="hljs-number">6</span> | <span class="hljs-number">192</span> : (<span class="hljs-number">55296</span> == (h &amp; <span class="hljs-number">64512</span>) &amp;&amp; g + <span class="hljs-number">1</span> &lt; a.length &amp;&amp; <span class="hljs-number">56320</span> == (a.charCodeAt(g + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">64512</span>) ? (h = <span class="hljs-number">65536</span> + ((h &amp; <span class="hljs-number">1023</span>) &lt;&lt; <span class="hljs-number">10</span>) + (a.charCodeAt(++g) &amp; <span class="hljs-number">1023</span>),<br>        e[f++] = h &gt;&gt; <span class="hljs-number">18</span> | <span class="hljs-number">240</span>,<br>        e[f++] = h &gt;&gt; <span class="hljs-number">12</span> &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>) : e[f++] = h &gt;&gt; <span class="hljs-number">12</span> | <span class="hljs-number">224</span>,<br>        e[f++] = h &gt;&gt; <span class="hljs-number">6</span> &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>),<br>        e[f++] = h &amp; <span class="hljs-number">63</span> | <span class="hljs-number">128</span>)<br>    &#125;<br>    a = b;<br>    <span class="hljs-keyword">for</span> (f = <span class="hljs-number">0</span>; f &lt; e.length; f++)<br>        a += e[f],<br>        a = yu(a, <span class="hljs-string">&quot;+-a^+6&quot;</span>);<br>    a = yu(a, <span class="hljs-string">&quot;+-3^+b+-f&quot;</span>);<br>    a ^= <span class="hljs-built_in">Number</span>(d[<span class="hljs-number">1</span>]) || <span class="hljs-number">0</span>;<br>    <span class="hljs-number">0</span> &gt; a &amp;&amp; (a = (a &amp; <span class="hljs-number">2147483647</span>) + <span class="hljs-number">2147483648</span>);<br>    a %= <span class="hljs-number">1E6</span>;<br>    <span class="hljs-keyword">return</span> c + (a.toString() + <span class="hljs-string">&quot;.&quot;</span> + (a ^ b))<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>直接把这段代码放到 html 中进行测试，控制台报错（没有定义 zu）。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p7.png" alt="p7"></p>
<p>发现在源码中 Au 函数的前面有定义 zu，于是乎将其找到（使用跳转功能会很方便）并放进测试代码中，然后重新测试。再次报错：没有定义 xu。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p8.png" alt="p8"></p>
<p>可能中途还会遇到几次这样的错误，重复上面的方法直至没有报错即可。然后就可以正常生成 tk 参数了，如果你不想要返回的值带有 &amp;tk=，你可以将 Au 函数最后的<code>return c + (a.toString() + &quot;.&quot; + (a ^ b))</code>替换成<code>return  (a.toString() + &quot;.&quot; + (a ^ b))</code>。</p>
<p><img src="/Python/2020-08-08-google-translation-js-crack/p9.png" alt="image-20200808112916825"></p>
<p>到此，我们通过 js 代码获得了 tk 参数的值。<br>你以为到这就完了？No no no，事情还没有结束。<br>刚开始对于获得的 tk 值我并没太仔细看，以至于没注意小数点前后的数是一样的，这导致我后面用 python 代码测试的时候老是出错（粗心啊 T_T）。后来发现这是由 zu 的初始值错误所导致的，zu 最开始被复制为 null，实际上后来它会变成一个具体的值（443549.1213991190），重新给 zu 赋值就好了。</p>
<blockquote>
<p>以上就是破解谷歌 js 的过程了</p>
</blockquote>
<p>破解有道和百度翻译 js 的过程和谷歌类似，因此也不再过多的赘述了，可以多自己尝试一下。<br>总的来说，谷歌、有道和百度翻译的 js 破解还是比较简单的，但刚开始接触还是摸索了很久，不过最后也获取到了相应的参数。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下生成项目目录树结构</title>
    <url>/Windows/2020-08-11-directory-tree-stucture/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个好的项目应该具有一个简洁明了的 README 文件，而 README 文件中的目录树结构能让读者很<br>好的了解你的项目。当文件结构比较简单的时候，逐行手动打出来倒不是太大的问题，但是当项目<br>文件比较多，结构相对复杂的时候，手动打出来就比较费劲了。这时，自动生成目录树结构的方法<br>就显得尤为重要。</p>
<h1 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h1><h2 id="Windows-自带的-tree-命令"><a href="#Windows-自带的-tree-命令" class="headerlink" title="Windows 自带的 tree 命令"></a>Windows 自带的 tree 命令</h2><ul>
<li><code>tree /a</code></li>
<li><code>tree /f</code></li>
</ul>
<p><code>tree /a</code>的效果如下：</p>
<p><img src="/Windows/2020-08-11-directory-tree-stucture/s1.png" alt="s1"></p>
<p><code>tree /f</code>的效果如下：</p>
<p><img src="/Windows/2020-08-11-directory-tree-stucture/s2.png" alt="s2"></p>
<p>如果想把目录结构输出到文件里，可以使用<code>tree /f &gt; tree.txt</code>命令。</p>
<p><strong>注意</strong>：Windows 的 tree 命令并不能用在 git 工具中，如果想要在 git 命令行工具中使用 tree 命令，则必须要下载 tree 应用。</p>
<blockquote>
<p>解决方法</p>
</blockquote>
<ul>
<li>下载 tree 应用支持，链接：<a href="https://links.jianshu.com/go?to=http://gnuwin32.sourceforge.net/packages/tree.htm">http://gnuwin32.sourceforge.net/packages/tree.htm</a>，选择 Binaries 版本</li>
<li>下载后将其解压并将 bin 目录下的 tree.exe 复制到安装 git 的 usr/bin 目录里</li>
</ul>
<h2 id="git-中使用-tree-命令"><a href="#git-中使用-tree-命令" class="headerlink" title="git 中使用 tree 命令"></a>git 中使用 tree 命令</h2><ul>
<li><p>基本使用：<code>tree [command] [params]</code></p>
</li>
<li><p>常用参数</p>
</li>
</ul>
<p>下面一些是比较常用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>列出所有文件</td>
</tr>
<tr>
<td>-N</td>
<td>原样打印</td>
</tr>
<tr>
<td>-r</td>
<td>按字母数字倒序排列文件</td>
</tr>
<tr>
<td>-L level</td>
<td>向下深入的层数</td>
</tr>
<tr>
<td>-A</td>
<td>打印 ANSI 线图形压痕线</td>
</tr>
<tr>
<td>-I pattern</td>
<td>忽略文件或文件夹</td>
</tr>
<tr>
<td>-o</td>
<td>输出文件路径</td>
</tr>
<tr>
<td>–charset X</td>
<td>指定编码</td>
</tr>
</tbody></table>
<p> 更多的相关命令和参数可以通过<code>tree --help</code>查询。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Directory Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中实现不换行输出</title>
    <url>/Python/2020-08-11-print-without-newline/</url>
    <content><![CDATA[<p>在 Python 里要想不换行输出，其实很简单，只需要像下面这样打印信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>    print(<span class="hljs-string">&#x27;\r目前进度为：[%s] %.2f%%&#x27;</span> % (i * <span class="hljs-string">&quot;#&quot;</span>, i * <span class="hljs-number">100</span> / <span class="hljs-number">100</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>实际上，Python 打印信息时的<code>end</code>默认为<code>\n</code>（即换行符），同时将光标提到最新行的最前面，相当于执行了<code>print(&quot;\n\r&quot;)</code>，这样就实现了换行输出 。那如果想要不换行输出就很简单了，只需要将<code>end</code>指定为空字符串（即不换行），同时加入<code>\r</code>，这样就可以了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Pyinstaller过程中遇到的一些问题</title>
    <url>/Python/2020-08-12-problems-during-using-pyinstaller/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时候，我们用 Python 编写好了程序，但想要发布给没有安装 Python 环境的人使用，如果让别人从 0 开始安装运行环境、第三方库，那估计黄花菜都凉了。因此，将 Python 程序打包成可执行的文件就相当有必要了。实际上，Python 中的第三方库 PyInstaller 可以很好的解决这个问题。</p>
<h1 id="打包单个程序"><a href="#打包单个程序" class="headerlink" title="打包单个程序"></a>打包单个程序</h1><p>对于单个 Python 程序的打包，非常简单，可以直接使用以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pyinstaller -F -w -i icon.ico xxx.py<br></code></pre></td></tr></table></figure>

<p><strong>-F</strong>: 打包成单个可执行文件<br>**-w**: 去掉启动软件后的黑色窗口<br>**-i**: 为程序添加图标</p>
<p>稍等片刻后，就会在 Python 程序所在目录下的 dist 文件夹中生成打包好的可执行文件。</p>
<h1 id="打包时引入外部文件"><a href="#打包时引入外部文件" class="headerlink" title="打包时引入外部文件"></a>打包时引入外部文件</h1><p>但往往我们打包程序并不只限于单个文件，可能还需要引入自己编写的 Python 模块、图片、文本或者其他文件，这时打包的情况就变得复杂许多，需要借助打包时生成的的 xxx.spec 文件引入外部的资源文件。</p>
<p>那么如何生成 spec 文件？可以通过下面 2 中方法生成 spec 文件：</p>
<ol>
<li><p><code>pyinstaller -F xxx.py</code>命令</p>
<p>PS: 如果想打包成单个可执行文件，需要加上<code>-F</code>参数</p>
<p>然后在程序的所在的目录下，会生成 build 和 dist 文件夹以及 xxx.spec 文件，将两个文件夹删掉（后面打包时会重新生成）。</p>
</li>
<li><p><code>pyi-makespec xxx.py</code>命令</p>
<p>这样只会生成一个 xxx.spec 文件。</p>
</li>
</ol>
<p>xxx.spec 长下面这样子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># -*- mode: python ; coding: utf-8 -*-</span><br><br>block_cipher = None<br><br><br>a = Analysis([<span class="hljs-string">&#x27;test.py&#x27;</span>],<br>             pathex=[<span class="hljs-string">&#x27;C:\\Users\\lei\\Desktop\\test&#x27;</span>],<br>             binaries=[],<br>             datas=[],<br>             hiddenimports=[],<br>             hookspath=[],<br>             runtime_hooks=[],<br>             excludes=[],<br>             <span class="hljs-attribute">win_no_prefer_redirects</span>=<span class="hljs-literal">False</span>,<br>             <span class="hljs-attribute">win_private_assemblies</span>=<span class="hljs-literal">False</span>,<br>             <span class="hljs-attribute">cipher</span>=block_cipher,<br>             <span class="hljs-attribute">noarchive</span>=<span class="hljs-literal">False</span>)<br>pyz = PYZ(a.pure, a.zipped_data,<br>             <span class="hljs-attribute">cipher</span>=block_cipher)<br>exe = EXE(pyz,<br>          a.scripts,<br>          a.binaries,<br>          a.zipfiles,<br>          a.datas,<br>          [],<br>          <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;test&#x27;</span>,<br>          <span class="hljs-attribute">debug</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">bootloader_ignore_signals</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>          upx_exclude=[],<br>          <span class="hljs-attribute">runtime_tmpdir</span>=None,<br>          <span class="hljs-attribute">console</span>=<span class="hljs-literal">True</span> )<br></code></pre></td></tr></table></figure>

<p>引入外部资源文件时，需要关注几个地方：Analysis 中的第一个参数和 datas 参数。前者列表中的值表示要打包的 Python 文件；datas 参数则是要引入的一些文本、音频或者图像文件，传入参数时需要传入列表，列表中需要写成元组，如：[(&#39;folder1\test1.txt&#39;, &#39;folder1&#39;)]，前者表示文件所在的相对路径，后者表示打包后所在的路径（如果打包在根目录，需要写成[(&#39;folder1\test1.txt&#39;, &#39;.&#39;)]。</p>
<p>一个打包示例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># -*- mode: python ; coding: utf-8 -*-</span><br><br>block_cipher = None<br><br>py_files = [<br>    <span class="hljs-string">&#x27;Demo.py&#x27;</span>,<br>    <span class="hljs-string">&#x27;api\\baidu.py&#x27;</span>,<br>    <span class="hljs-string">&#x27;api\\google.py&#x27;</span>,<br>    <span class="hljs-string">&#x27;api\\youdao.py&#x27;</span>,<br>    <span class="hljs-string">&#x27;ui\\MainWindow.py&#x27;</span><br>]<br><br>datas = [<br>    (<span class="hljs-string">&#x27;assets\\icon.png&#x27;</span>, <span class="hljs-string">&#x27;assets&#x27;</span>),<br>    (<span class="hljs-string">&#x27;javascript\\*.js&#x27;</span>, <span class="hljs-string">&#x27;javascript&#x27;</span>)<br>]<br><br>a = Analysis(py_files,<br>             pathex=[<span class="hljs-string">&#x27;F:\\Python\\谷歌、有道、百度翻译\\Translator&#x27;</span>],<br>             binaries=[],<br>             <span class="hljs-attribute">datas</span>=datas,<br>             hiddenimports=[],<br>             hookspath=[],<br>             runtime_hooks=[],<br>             excludes=[],<br>             <span class="hljs-attribute">win_no_prefer_redirects</span>=<span class="hljs-literal">False</span>,<br>             <span class="hljs-attribute">win_private_assemblies</span>=<span class="hljs-literal">False</span>,<br>             <span class="hljs-attribute">cipher</span>=block_cipher,<br>             <span class="hljs-attribute">noarchive</span>=<span class="hljs-literal">False</span>)<br>pyz = PYZ(a.pure, a.zipped_data,<br>             <span class="hljs-attribute">cipher</span>=block_cipher)<br>exe = EXE(pyz,<br>          a.scripts,<br>          a.binaries,<br>          a.zipfiles,<br>          a.datas,<br>          [],<br>          <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Demo&#x27;</span>,<br>          <span class="hljs-attribute">debug</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">bootloader_ignore_signals</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>          <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>          upx_exclude=[],<br>          <span class="hljs-attribute">runtime_tmpdir</span>=None,<br>          <span class="hljs-attribute">console</span>=<span class="hljs-literal">False</span>,<br>               <span class="hljs-attribute">icon</span>=<span class="hljs-string">&#x27;assets\\icon.ico&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>Analysis 中的参数设置好了，还可以设置 EXE 中的一些参数，例如：设置 name 参数的值以指定打包程序的名字，设置 console 为 False 以去除启动程序时产生的黑色窗口，另外还可以设置 icon 的值为程序添加图标。</p>
<p>通过以上对 spec 文件的设置就可以打包外部资源文件到程序中，但这还没有结束。打包完成后一运行程序，就会发现报错，提示找不到对应的外部文件。这就奇了怪了，我不是已经打包到程序里面了吗？</p>
<p>最后，在网上一通搜索，发现了一个问题，当运行打包后的程序时，会生成一个临时文件夹，程序是通过此临时文件夹去访问外部资源的，如果 Python 程序中是按照常规方式引用外部文件的话，那必然会报错。所以，我们需要对文件的搜索做一点改变。</p>
<p>在源代码中添加以下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resource_path</span>(<span class="hljs-params">relative_path</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">      获取正确的文件路径</span><br><span class="hljs-string">      &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> getattr(sys, <span class="hljs-string">&#x27;frozen&#x27;</span>, <span class="hljs-literal">None</span>):<br>        base_path = sys._MEIPASS<br>    <span class="hljs-keyword">else</span>:<br>        base_path = os.path.dirname(__file__)<br>    <span class="hljs-keyword">return</span> os.path.join(base_path, relative_path)<br></code></pre></td></tr></table></figure>

<p>然后将源代码中引用文件的路径参数替换成<code>resource_path(relative_path)</code>，这样再运行打包后的程序就不会出错了，也可以放心的发布给别人使用了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>编写批处理命令时遇到的坑</title>
    <url>/Python/2020-08-13-some-problems-with-bat/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近写了一个脚本，每次运行都要在对应的目录下打开命令行，然后输入<code>python main.py</code>命令或者直接输入<code>python xxx\xxx\xxx\xxx\xxx\main.py</code>命令，也不是特别复杂，但对于想偷懒的我来说还是很麻烦，所以写一个批处理命令(bat)，直接双击运行，岂不美哉。<br>批处理命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>python F:\Python项目\安卓App\AutoRead\main.py<br>pause<br></code></pre></td></tr></table></figure>

<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>但是一运行就会报<code>python: can&#39;t open file &#39;&lt;unprintable file name&gt;&#39;: [Errno 2] No such file or directory</code>错误，在网上搜索了很多答案，都没有找到解决问题的办法。<br>没办法了，只能自己慢慢摸索了。</p>
<h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><p>尝试先<code>cd</code>到 python 文件所在的目录，然后再运行脚本。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex">f:<br>cd Python项目<span class="hljs-tag">\<span class="hljs-name">安</span></span>卓App<span class="hljs-tag">\<span class="hljs-name">AutoRead</span></span><span class="hljs-tag">\</span><br>python main.py<br>pause<br></code></pre></td></tr></table></figure>

<p>但依旧会报上面的错误。<br>然后手动尝试在命令行窗口执行命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex">python F:<span class="hljs-tag">\<span class="hljs-name">Python</span></span>项目<span class="hljs-tag">\<span class="hljs-name">安</span></span>卓App<span class="hljs-tag">\<span class="hljs-name">AutoRead</span></span><span class="hljs-tag">\<span class="hljs-name">main</span></span>.py<br></code></pre></td></tr></table></figure>

<p>不报错。再尝试：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><code class="hljs latex">f:<br>cd Python项目<span class="hljs-tag">\<span class="hljs-name">安</span></span>卓App<span class="hljs-tag">\<span class="hljs-name">AutoRead</span></span><span class="hljs-tag">\</span><br>python main.py<br></code></pre></td></tr></table></figure>

<p>也不报错，这让我有点懵逼了。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>正在思考是怎么回事的时候，突然我注意到路径中有中文，脑子一闪，这可能是由于 bat 文件的编码问题所导致的。在网上搜索了一下，发现的确是由于编码所导致的中文乱码问题<sup>[1]</sup>。建立的批处理文件默认是 UTF-8 编码格式，不能正确显示中文内容，所以会乱码，只需要在写好批处理命令后，将其另存为，同时编码选择 ANSI，再运行就不会出现乱码了。<br>改好后重新运行也没有再报错^_^。</p>
<blockquote>
<p>在搜索时发现还有另外一种解决方法<sup>[2]</sup>：</p>
<p>通过<code>chcp 65001</code>命令（UTF-8 的代码页为 65001）改变代码页，然后再运行脚本，这样也可以正常运行。</p>
</blockquote>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>[1] <a href="https://blog.csdn.net/huige6941/article/details/85320066">https://blog.csdn.net/huige6941/article/details/85320066</a></p>
<p>[2] <a href="https://www.cnblogs.com/laughingQing/p/4554980.html">https://www.cnblogs.com/laughingQing/p/4554980.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Bat</tag>
      </tags>
  </entry>
  <entry>
    <title>Python制作天气查询助手</title>
    <url>/Python/2020-08-28-weather-assistant/</url>
    <content><![CDATA[<p>今天闲来无事，想写个查天气的脚本。Idea 在手，拿起 Python 干就完事了。<br>首先找一个比较靠谱的天气数据网站，这里我选的是<a href="http://www.weather.com.cn/">中国天气网</a>，如下图所示，</p>
<p><img src="/Python/2020-08-28-weather-assistant/s1.png" alt="s1"></p>
<p>随便搜索一个城市的天气试试，当前的 URL 为：<a href="http://www.weather.com.cn/weather1d/101270101.shtml#input">http://www.weather.com.cn/weather1d/101270101.shtml#input</a></p>
<p><img src="/Python/2020-08-28-weather-assistant/s2.png" alt="s2"></p>
<p>URL 中的 101270101 猜测应该是城市的 id 之类的，那么如果要查询不同的城市的天气数据，首先得找到城市名和这个 id 的对应关系。<br>回到起初搜索的地方，观察一下网络请求。</p>
<p><img src="/Python/2020-08-28-weather-assistant/s3.png" alt="s3"></p>
<p>发现网络面板中有含有 search 关键字的请求，具体内容过如下：</p>
<p><img src="/Python/2020-08-28-weather-assistant/s4.png" alt="s4"></p>
<p>Nice！这个请求里面包含了城市的 id。请求的 URL 为：<a href="http://toy1.weather.com.cn/search?cityname=%E6%88%90%E9%83%BD&callback=success_jsonpCallback&_=1598586444643">http://toy1.weather.com.cn/search?cityname=%E6%88%90%E9%83%BD&amp;callback=success_jsonpCallback&amp;_=1598586444643</a>，请求方法为 GET，然后分析一下具体的请求参数：</p>
<blockquote>
<p>‘cityname’: 成都</p>
<p>‘callback’: success_jsonpCallback</p>
<p>‘_’: 1598586444643</p>
</blockquote>
<p>cityname 是城市的名称，callback 不知其具体意义，_ 一看就知道是时间戳。<br>那这样就很简单了，写一段简单的代码就可以获取到城市的 id：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">headers = &#123;<br>      <span class="hljs-string">&quot;User-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 Edg/84.0.522.59&quot;</span>,<br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;http://www.weather.com.cn/weather1d/101271201.shtml&quot;</span><br>&#125;<br>city_name = <span class="hljs-string">&quot;成都&quot;</span><br>timestamp = int(time.time() * <span class="hljs-number">1000</span>)<br>url = <span class="hljs-string">f&quot;http://toy1.weather.com.cn/search?cityname=<span class="hljs-subst">&#123;city_name&#125;</span>&amp;callback=success_jsonpCallback&amp;_=<span class="hljs-subst">&#123;timestamp&#125;</span>&quot;</span><br>response = requests.get(url, headers=headers)<br>city_ip = re.findall(<span class="hljs-string">r&quot;\d&#123;9&#125;&quot;</span>, response.text)[<span class="hljs-number">0</span>]<br>print(city_ip)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果 headers 里不添加 Referer，就会出现 403 错误码，在这里也是栽了跟头。</p>
</blockquote>
<p>解决了城市 ip 的问题，接下来就要获取页面上的天气数据了。<br>把页面上的主要数据分为 3 个部分，如下所示。</p>
<img src="/Python/2020-08-28-weather-assistant/s5.png" width="500">

<p>对于第 1 板块的数据，在源代码中并没有发现，说明是异步加载的数据。<br>然后在网络面板中发现了一个请求，里面由对应的信息，如下所示：</p>
<p><img src="/Python/2020-08-28-weather-assistant/s6.png" alt="s6"></p>
<p>该请求的请求 URL 为：[<a href="http://d1.weather.com.cn/sk_2d/101270101.html?_=1598588972022%5D">http://d1.weather.com.cn/sk_2d/101270101.html?_=1598588972022]</a>(<a href="http://d1.weather.com.cn/sk_2d/101270101.html?_=1598588972022%EF%BC%8C%E4%B9%8B%E5%89%8D%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E5%9F%8E%E5%B8%82">http://d1.weather.com.cn/sk_2d/101270101.html?_=1598588972022，之前获取到的城市</a> ip 在这同样适用。写一段代码来获取这个数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cip = <span class="hljs-string">&quot;101270101&quot;</span><br>timestamp = int(time.time() * <span class="hljs-number">1000</span>)<br>url = <span class="hljs-string">f&quot;http://d1.weather.com.cn/sk_2d/<span class="hljs-subst">&#123;cip&#125;</span>.html?_=<span class="hljs-subst">&#123;timestamp&#125;</span>&quot;</span><br>response = requests.get(url)<br>response.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br>content = response.text<br></code></pre></td></tr></table></figure>

<p>然后解析数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 温度</span><br>temp = re.findall(<span class="hljs-string">&#x27;&quot;temp&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;°C&quot;</span><br><span class="hljs-comment"># 风向</span><br>wd = re.findall(<span class="hljs-string">&#x27;&quot;WD&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 风速</span><br>ws = re.findall(<span class="hljs-string">&#x27;&quot;WS&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 湿度</span><br>sd = re.findall(<span class="hljs-string">&#x27;&quot;SD&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 时间</span><br>time_ = re.findall(<span class="hljs-string">&#x27;&quot;time&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 天气状况</span><br>weather = re.findall(<span class="hljs-string">&#x27;&quot;weather&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 能见度</span><br>njd = re.findall(<span class="hljs-string">&#x27;&quot;njd&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 降雨</span><br>rain = re.findall(<span class="hljs-string">&#x27;&quot;rain&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 空气质量</span><br>aqi = re.findall(<span class="hljs-string">&#x27;&quot;aqi&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 日期</span><br>date_ = re.findall(<span class="hljs-string">&#x27;&quot;date&quot;:&quot;(.*?)&quot;&#x27;</span>, content)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>对于第 2 个板块的数据，在源代码中可以搜索到，因此我们可以直接用 requests 获取对应的数据，然后用 bs4 或者其他的解析库解析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">f&quot;http://www.weather.com.cn/weather1d/<span class="hljs-subst">&#123;cip&#125;</span>.shtml#input&quot;</span><br>response = requests.get(url)<br>response.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br>html = response.text<br>soup = BeautifulSoup(html, <span class="hljs-string">&quot;lxml&quot;</span>)<br><br><span class="hljs-comment"># 第一列数据</span><br>li1 = soup.select(<span class="hljs-string">&quot;div.t &gt; ul.clearfix &gt; li&quot;</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 白天 or 夜间</span><br>type1 = li1.select(<span class="hljs-string">&quot;h1&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br><span class="hljs-comment"># 天气状况</span><br>weather1 = li1.select(<span class="hljs-string">&quot;p.wea&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br><span class="hljs-comment"># 温度</span><br>temp1 = li1.select(<span class="hljs-string">&quot;p.tem&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br><span class="hljs-comment"># 风速</span><br>ws1 = li1.select(<span class="hljs-string">&quot;p.win &gt; span&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br><span class="hljs-comment"># 第二列数据</span><br>li2 = soup.select(<span class="hljs-string">&quot;div.t &gt; ul.clearfix &gt; li&quot;</span>)[<span class="hljs-number">1</span>]<br>type2 = li2.select(<span class="hljs-string">&quot;h1&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br>weather2 = li2.select(<span class="hljs-string">&quot;p.wea&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br>temp2 = li2.select(<span class="hljs-string">&quot;p.tem&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br>ws2 = li2.select(<span class="hljs-string">&quot;p.win &gt; span&quot;</span>)[<span class="hljs-number">0</span>].text.strip()<br></code></pre></td></tr></table></figure>

<p>对于第 3 个板块的数据，在源代码中也不能直接搜索到，应该是 js 返回的数据，但找了很久，我都没有找到。最后利用全局搜索（Ctrl + Shift + F），在 html 文档的 script 标签中找到了对应的数据，如下所示：</p>
<p><img src="/Python/2020-08-28-weather-assistant/s7.png" alt="s7"></p>
<p>这样，要获取数据就很简单了，直接用 requests 库获取页面，然后用正则表达式或者解析库提取 script 标签中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cip = <span class="hljs-string">&quot;101270101 &quot;</span><br>url = <span class="hljs-string">f&quot;ttp://www.weather.com.cn/weather1d/<span class="hljs-subst">&#123;cip&#125;</span>.shtml#input&quot;</span><br>response = requests.get(url, headers=headers)<br>response.encoding = <span class="hljs-string">&quot;utf-8&quot;</span><br>html = response.text<br>soup = BeautifulSoup(html, <span class="hljs-string">&quot;lxml&quot;</span>)<br>script = soup.select(<span class="hljs-string">&quot;div#today &gt; script&quot;</span>)[<span class="hljs-number">1</span>].text.strip().strip(<span class="hljs-string">&quot;var hour3data=&quot;</span>)<br>json_ = json.loads(script)<br>data = json_[<span class="hljs-string">&quot;1d&quot;</span>]  <span class="hljs-comment"># 获取 1 天的数据</span><br>time_list = []<br>temp_list = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data)):<br>  time_ = data[i].split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]<br>  temp = data[i].split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">3</span>]<br>  time_list.append(time_)<br>  temp_list.append(temp)<br>  time_list = [re.findall(<span class="hljs-string">&quot;\d+&quot;</span>, i)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;-&quot;</span> + re.findall(<span class="hljs-string">&quot;\d+&quot;</span>, i)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> time_list]<br>  temp_list = [int(i.strip(<span class="hljs-string">&quot;℃&quot;</span>)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp_list]<br></code></pre></td></tr></table></figure>

<p>至此，页面上主要的数据就获取完了，接下来将其输出就行了。<br>但光是这样我还没有满足，总觉得没有一个像样的 GUI 就缺了点啥。<br>GUI 的实现采用的是 PyQt5（推荐先用 Qt Designer 设计好界面，然后转换成 python 代码，这样会方便很多）。有了界面和控件，然后需要把控件和事件绑定起来，并将 matplotlib 绘制的图像显示在界面中<sup>[1]</sup>。<br>不过有个坑需要注意一下，就是图片的刷新问题。图片是不会自己刷新的，得做一点小改动。在网上搜索了很多相关博客<sup>[2]</sup>，基本上都说的下面这种方法，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.axes.cla()<br>self.axes.plot(x, y)<br>self.draw()<br></code></pre></td></tr></table></figure>

<p>但这样并没有什么卵用，一运行就会卡死或者闪退。怎么搜索也找不到解决方法，就很崩溃。不过黄天不负有心人，在知乎上看到了一篇文章<sup>[3]</sup>，有所启发。在刷新图片之前，需要通过 sip.delete（from PyQt5 import sip）命令删除 layout 中的 widget，这相当于删掉画板，然后重新添加画布和画板，并重新绘图，这样就可以实现图片的刷新。<br>简略代码（请结合源码理解上述内容）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.flag = <span class="hljs-number">0</span>  <span class="hljs-comment"># 判断是首次查询还是非首次查询</span><br><span class="hljs-keyword">if</span> self.flag == <span class="hljs-number">0</span>:<br>    self.F = PlotFigure(width=<span class="hljs-number">3</span>, height=<span class="hljs-number">2</span>, dpi=<span class="hljs-number">80</span>)  <span class="hljs-comment"># 实例化画布</span><br>    self.F.plot(curve_data)  <span class="hljs-comment"># 绘图</span><br>    self.gridLayout.addWidget(self.F, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 添加 widget</span><br>    self.flag += <span class="hljs-number">1</span>  <span class="hljs-comment"># 查询了就 +1</span><br><span class="hljs-keyword">else</span>:<br>    sip.delete(self.F)  <span class="hljs-comment"># 删除画板</span><br>    self.F = PlotFigure(width=<span class="hljs-number">3</span>, height=<span class="hljs-number">2</span>, dpi=<span class="hljs-number">80</span>)<br>    self.F.plot(curve_data)<br>    self.gridLayout.addWidget(self.F, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>做了如此改动后，程序就可以正常运行了。<br>运行结果如下，</p>
<center>
  <img src="/Python/2020-08-28-weather-assistant/s8.png" width="400">
  <img src="/Python/2020-08-28-weather-assistant/s9.png" width="400">
</center><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接<p>[1] <a href="https://blog.csdn.net/panrenlong/article/details/80183519">https://blog.csdn.net/panrenlong/article/details/80183519</a></p>
<p>[2] <a href="https://blog.csdn.net/wuwei_201/article/details/106106387">https://blog.csdn.net/wuwei_201/article/details/106106387</a></p>
<p>[3] <a href="https://zhuanlan.zhihu.com/p/191533944">https://zhuanlan.zhihu.com/p/191533944</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web Spider</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的openpyxl模块</title>
    <url>/Python/2020-09-20-python-openpyxl/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install openpyxl<br></code></pre></td></tr></table></figure>

<h1 id="打开表格"><a href="#打开表格" class="headerlink" title="打开表格"></a>打开表格</h1><ul>
<li>创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br><span class="hljs-comment"># 实例化</span><br>work_book = WorkBook()<br><span class="hljs-comment"># 选择 sheet</span><br>sheet = work_book.active<br></code></pre></td></tr></table></figure>

<ul>
<li>从文件读取</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br>work_book = openpyxl.load_workbook(<span class="hljs-string">&quot;sample.xlsx&quot;</span>)  <span class="hljs-comment"># 不支持后缀为 xls 的文件</span><br></code></pre></td></tr></table></figure>

<h1 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br>work_book = openpyxl.WorkBook()<br>work_book.save(<span class="hljs-string">&quot;sample.xlsx&quot;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>sheet[<span class="hljs-string">&quot;A1&quot;</span>] = <span class="hljs-number">12</span>  <span class="hljs-comment"># 通过 字母+数字 的索引方法找到单元格</span><br>sheet.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>) = <span class="hljs-number">12</span>  <span class="hljs-comment"># 通过 行+列 的索引方法找到单元格</span><br></code></pre></td></tr></table></figure>

<h1 id="创建-sheet"><a href="#创建-sheet" class="headerlink" title="创建 sheet"></a>创建 sheet</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>work_book.create_sheet(<span class="hljs-string">&quot;NewSheet&quot;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="选择-sheet"><a href="#选择-sheet" class="headerlink" title="选择 sheet"></a>选择 sheet</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br><span class="hljs-comment"># 推荐方法一</span><br>work_book[<span class="hljs-string">&quot;sheet_name&quot;</span>]  <span class="hljs-comment"># 方法一</span><br>work_book.get_sheet_by_name(<span class="hljs-string">&quot;sheet_name&quot;</span>)  <span class="hljs-comment"># 方法二</span><br></code></pre></td></tr></table></figure>

<h1 id="查看和修改-sheet-名"><a href="#查看和修改-sheet-名" class="headerlink" title="查看和修改 sheet 名"></a>查看和修改 sheet 名</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>sheet_name = sheet.title  <span class="hljs-comment"># 查看表名</span><br>sheet.title = <span class="hljs-string">&quot;changed title&quot;</span>  <span class="hljs-comment">#修改表名</span><br></code></pre></td></tr></table></figure>

<h1 id="访问单元格"><a href="#访问单元格" class="headerlink" title="访问单元格"></a>访问单元格</h1><ul>
<li>单一单元格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>cell = sheet[<span class="hljs-string">&quot;A1&quot;</span>]  <span class="hljs-comment"># 方法一</span><br>cell = sheet.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 方法二</span><br></code></pre></td></tr></table></figure>

<ul>
<li>多单元格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>cells = sheet[<span class="hljs-string">&quot;A1:B2&quot;</span>]<br></code></pre></td></tr></table></figure>

<h1 id="循环访问单元格"><a href="#循环访问单元格" class="headerlink" title="循环访问单元格"></a>循环访问单元格</h1><ul>
<li>方法一</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br>rows = sheet[<span class="hljs-string">&quot;A1:B2&quot;</span>]<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:<br>      <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>          print(cell.value)<br></code></pre></td></tr></table></figure>

<ul>
<li>方法二</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>      <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>          print(sheet.cell(row=row, column=column))<br></code></pre></td></tr></table></figure>

<ul>
<li>方法三</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> work_book.iter_rows(min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">3</span>, min_col=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>):<br>      <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>          print(cell.value)<br></code></pre></td></tr></table></figure>

<ul>
<li>方法四</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> work_book.iter_cols(min_row=<span class="hljs-number">1</span>, max_row=<span class="hljs-number">3</span>, min_col=<span class="hljs-number">1</span>, max_col=<span class="hljs-number">3</span>):<br>      <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> column:<br>          print(cell.value)<br></code></pre></td></tr></table></figure>

<ul>
<li>方法五</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.rows:<br>      <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row:<br>          print(cell.value)<br></code></pre></td></tr></table></figure>

<ul>
<li>方法六</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> sheet.columns:<br>      <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> column:<br>          print(cell.value)<br></code></pre></td></tr></table></figure>

<h1 id="获取单元格所在行和列"><a href="#获取单元格所在行和列" class="headerlink" title="获取单元格所在行和列"></a>获取单元格所在行和列</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.acitve<br>cell = shett.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>)<br>row, column = cell.row, cell.column<br></code></pre></td></tr></table></figure>

<h1 id="根据数字得到字母，根据字母得到数字"><a href="#根据数字得到字母，根据字母得到数字" class="headerlink" title="根据数字得到字母，根据字母得到数字"></a>根据数字得到字母，根据字母得到数字</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><span class="hljs-comment"># 导入需要的类</span><br><span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> get_column_letter, column_index_from_string<br><br><span class="hljs-comment"># 根据列数得到对应的字母</span><br>print(get_column_letter(<span class="hljs-number">2</span>))<br><span class="hljs-comment"># 根据字母得到对应的列数</span><br>print(column_index_from_string(<span class="hljs-string">&quot;B&quot;</span>))<br></code></pre></td></tr></table></figure>

<h1 id="设置单元格风格"><a href="#设置单元格风格" class="headerlink" title="设置单元格风格"></a>设置单元格风格</h1><ul>
<li>字体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入需要的类</span><br><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Font, colors, Alignment<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><span class="hljs-comment"># name: 字体名称</span><br><span class="hljs-comment"># size: 字体大小</span><br><span class="hljs-comment"># italic: 是否斜体</span><br><span class="hljs-comment"># color: 字体颜色</span><br><span class="hljs-comment"># bold: 是否加粗</span><br>sheet[<span class="hljs-string">&quot;A1&quot;</span>].font = Font(name=<span class="hljs-string">&quot;等线&quot;</span>, size=<span class="hljs-number">24</span>, italic=<span class="hljs-literal">True</span>, color=colors.RED, bold=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>设置行高和列宽</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br><span class="hljs-comment"># 行高和列宽是针对行或列进行设置的，不能单独对单元格进行设置</span><br>sheet.row_dimensions[<span class="hljs-number">2</span>].height = <span class="hljs-number">40</span>  <span class="hljs-comment"># 设置第 2 行行高为 40</span><br>sheet.column_dimensions[<span class="hljs-string">&quot;C&quot;</span>].width = <span class="hljs-number">12</span>  <span class="hljs-comment"># 设置 C 列列宽为 12</span><br></code></pre></td></tr></table></figure>

<ul>
<li>设置对齐方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Alignment<br><br>work_book = WorkBook()<br>sheet = work_book.active<br><br><span class="hljs-comment"># horizontal: 水平对齐方式</span><br><span class="hljs-comment"># vertical: 垂直对齐方式</span><br><span class="hljs-comment"># wrap_text: 是否自动换行，True 表示自动换行</span><br>sheet[<span class="hljs-string">&quot;A1&quot;</span>].alignment = Alignment(horizontal=<span class="hljs-string">&quot;center&quot;</span>, vertical=<span class="hljs-string">&quot;center&quot;</span>, wrap_text=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><p>合并和拆分单元格</p>
<ul>
<li>获取所有合并的单元格</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><span class="hljs-keyword">from</span> openpyxl.styles <span class="hljs-keyword">import</span> Font, colors, Alignment<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>all_merged_cells = list(sheet.merged_cells)  <span class="hljs-comment"># 获取所有合并的单元格</span><br></code></pre></td></tr></table></figure>

<ul>
<li>合并单元格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>sheet.merge_cells(<span class="hljs-string">&quot;A1:B2&quot;</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>拆分单元格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> WorkBook<br><br>work_book = WorkBook()<br>sheet = work_book.active<br>sheet.unmerge_cells(<span class="hljs-string">&quot;A1:B2&quot;</span>)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中同时替换多个字符串的方法</title>
    <url>/Python/2020-09-21-python%E5%90%8C%E6%97%B6%E6%9B%BF%E6%8D%A2%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">str_ = <span class="hljs-string">&quot;abcead&quot;</span><br>result = str_.replace(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>).replace(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br>print(result)<br><br><span class="hljs-comment"># 结果：</span><br>cccecd<br></code></pre></td></tr></table></figure>

<h1 id="re-sub-方法"><a href="#re-sub-方法" class="headerlink" title="re.sub() 方法"></a>re.sub() 方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>str_ = <span class="hljs-string">&quot;abcdefg&quot;</span><br><span class="hljs-comment"># 第一个参数为正则表达式，第二个参数为替换后的字符串，第三个参数为待替换的字符串</span><br>result_1 = re.sub(<span class="hljs-string">&quot;[abc]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, str_)<br>print(result_1)<br><span class="hljs-comment"># 结果</span><br>defg<br><br>result_2 = re.sub(<span class="hljs-string">&quot;a|b|c&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, str_)<br><span class="hljs-comment"># 结果</span><br>defg<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
